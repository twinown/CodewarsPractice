package java_explanations.composition_agregation;
//HAS A ОТНОШЕНИЯ

//АГРЕГАЦИЯ - получение зависимостей снаружи
//то есть жизненный цикл зависимого объекта не зависит от владельца
//ты из В имеешь доступ к методу А
//основа депенденси инжектион и инвершн
public class B {
    private final A name;

    public B(A name) {
        this.name = name;
    }

    void show() {
        name.show();
    }
}

//КОМПОЗИЦИЯ,
//то есть жизненный цикл зависимого объекта полностью зависит от владельца
 class C{
    private final A state;

    //сильная связь
    //смотри, ниже 2 конструктора:то есть первый не мб без второго, но здесь всё равно композиция
    //по сути, они вдвоем заменяют инициализицию переменной выше, пока их уберем
    //эта х -ня ниже, как я понял, типо гибрид и композиции, и агрегации
    //когда передаёшь параметр в констр, то это агр, а если не передаёшь, то комп-ция
 /*  public C() {
       this(new A());
    }
    public C(A state){
       this.state = state;
    }*/

    //или вместо тех двух, что выше
    public C(){
       this.state = new A();
    }

    public void show(){
       state.show();
    }
}

//представь, что это активити (D), А - типо application
//ты должен создать объект А , НО
//у тебя конструктор пустой быть должен,D,тк вызывается из другого места из рефлексии, как и A
//также ты не можешь создать сам другой объект(инициализировать),который  нужен в этом объкте
//как по итогу сделать ,чтоб они взаимодействовали ? -через СЕТТЕР aka attach
//хочу из D иметь доступ к A
// используем сеттер...в андроид-мире - это называется attach ф-ция


//эту хрень ниже можно назвать как агрегация через функцию


class D{

    //есть два пути входа в объект из другого:
    //через конструктор
    //через функцию


    //вроде как тоже создаётся через рефлексию
    private A a;

    //объект этого класса создаётся через рефлексию
    public D(){
    }

//это сеттер он же аттач
    //доступ из одного объекта к другому
    public void attach(A a) {
        this.a = a;
    }

    public void detach(A a){
        a = null;
    }

    public void show(){
        a.show();
    }
}